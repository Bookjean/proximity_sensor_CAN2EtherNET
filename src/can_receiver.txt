#include <rclcpp/rclcpp.hpp>
#include <ecan_driver/msg/can_frame.hpp>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>
#include <thread>
#include <vector> // 컴파일 에러 방지를 위해 필수 추가
#include <std_msgs/msg/float32_multi_array.hpp>

class CanReceiverNode : public rclcpp::Node
{
public:
    CanReceiverNode() : Node("can_receiver")
    {
        // 파라미터 선언
        this->declare_parameter<std::string>("can_server_ip", "192.168.0.223");
        this->declare_parameter<int>("can_server_port", 4001);

        // 파라미터 가져오기
        std::string server_ip = this->get_parameter("can_server_ip").as_string();
        int server_port = this->get_parameter("can_server_port").as_int();

        // Publisher 생성
        prox_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>("proximity_distance", 10);
        tof_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>("tof_distance", 10);
        filtered_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>("filtered_distance", 10);

        // 소켓 연결
        if (!connect_to_server(server_ip, server_port)) {
            RCLCPP_ERROR(this->get_logger(), "Failed to connect to CAN server");
            return;
        }

        RCLCPP_INFO(this->get_logger(), "Connected to CAN server at %s:%d",
                    server_ip.c_str(), server_port);

        // 수신 스레드 시작
        receive_thread_ = std::thread(&CanReceiverNode::receive_loop, this);

        // 100 Hz 주기로 최신 값 발행
        using namespace std::chrono_literals;
        publish_timer_ = this->create_wall_timer(10ms, [this]() {
            prox_pub_->publish(prox_msgs_);
            filtered_pub_->publish(filtered_msgs_);
            tof_pub_->publish(tof_msgs_);
        });

        prox_msgs_.data = {0.0f, 0.0f};
        tof_msgs_.data = {0.0f, 0.0f};
        filtered_msgs_.data = {0.0f, 0.0f};
    }

    ~CanReceiverNode()
    {
        running_ = false;
        if (receive_thread_.joinable()) {
            receive_thread_.join();
        }
        if (socket_fd_ >= 0) {
            close(socket_fd_);
        }
    }

private:

    std_msgs::msg::Float32MultiArray prox_msgs_, tof_msgs_, filtered_msgs_;
    int count = 0;
    bool connect_to_server(const std::string& ip, int port)
    {
        socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd_ < 0) {
            RCLCPP_ERROR(this->get_logger(), "Failed to create socket");
            return false;
        }

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(port);

        if (inet_pton(AF_INET, ip.c_str(), &server_addr.sin_addr) <= 0) {
            RCLCPP_ERROR(this->get_logger(), "Invalid address: %s", ip.c_str());
            close(socket_fd_);
            return false;
        }

        if (connect(socket_fd_, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            RCLCPP_ERROR(this->get_logger(), "Connection failed");
            close(socket_fd_);
            return false;
        }

        return true;
    }

    void receive_loop()
    {
        uint8_t buffer[1024];
        std::vector<uint8_t> data_buffer;

        while (running_ && rclcpp::ok()) {
            ssize_t bytes_received = recv(socket_fd_, buffer, sizeof(buffer), 0);

            if (bytes_received <= 0) {
                if (bytes_received == 0) {
                    RCLCPP_WARN(this->get_logger(), "Connection closed by server");
                } else {
                    RCLCPP_ERROR(this->get_logger(), "Receive error");
                }
                break;
            }

            // 받은 데이터를 버퍼에 추가
            data_buffer.insert(data_buffer.end(), buffer, buffer + bytes_received);

            // 바이너리 프레임 파싱 (헤더 4 + ID 1 + DLC 1 + DATA 8 = 14바이트)
            const size_t FRAME_SIZE = 14;
            while (data_buffer.size() >= FRAME_SIZE) {
                parse_and_publish_binary_frame(data_buffer.data());
                data_buffer.erase(data_buffer.begin(), data_buffer.begin() + FRAME_SIZE);
            }
        }
    }

    void parse_and_publish_binary_frame(const uint8_t* frame)
    {
        // [프레임 구조]
        // [0-3]: 헤더
        // [4]: CAN ID
        // [5]: DLC
        // [6-13]: 데이터 Payload (8바이트)

        uint32_t can_id = frame[4];
        uint8_t dlc = frame[5];

        if (dlc > 8) {
            return;  // 유효하지 않은 DLC
        }

        // ==========================================
        //  수정됨: Big Endian 처리 & 나누기 삭제
        // ==========================================

        if (can_id == 0x41) {
            // [참고한 Sender 구조]
            // filtered_Q1 >> 24, 16, 8, 0 (Payload 0~3) -> frame[6]~[9]
            // adkf >> 24, 16, 8, 0        (Payload 4~7) -> frame[10]~[13]

            // 1. Distance (Big Endian)
            uint32_t distance =
                (static_cast<uint32_t>(frame[6]) << 24) |
                (static_cast<uint32_t>(frame[7]) << 16) |
                (static_cast<uint32_t>(frame[8]) << 8)  |
                (static_cast<uint32_t>(frame[9]) << 0);

            // 2. RAW (Big Endian)
            uint32_t raw =
                (static_cast<uint32_t>(frame[10]) << 24) |
                (static_cast<uint32_t>(frame[11]) << 16) |
                (static_cast<uint32_t>(frame[12]) << 8)  |
                (static_cast<uint32_t>(frame[13]) << 0);

            // 나누기 1000 없이 저장 (Decimal mm)
            prox_msgs_.data[0] = static_cast<float>(distance);
            filtered_msgs_.data[0] = static_cast<float>(raw);

        } else if (can_id == 0x42) {
            // [참고한 Sender 구조]
            // 0, 0, tof>>8, tof>>0 ...
            // Payload 2, 3 바이트 위치 -> frame[8], frame[9]

            // 3. ToF (Big Endian)
            // frame[8]이 상위 바이트(MSB)
            uint16_t tof = 
                (static_cast<uint16_t>(frame[8]) << 8) | 
                (static_cast<uint16_t>(frame[9]) << 0);

            // 나누기 1000 없이 저장 (Decimal mm)
            tof_msgs_.data[0] = static_cast<float>(tof);
        }
    }

    int socket_fd_ = -1;
    std::thread receive_thread_;
    std::atomic<bool> running_{true};

    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr prox_pub_, tof_pub_, filtered_pub_;
    rclcpp::TimerBase::SharedPtr publish_timer_;
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<CanReceiverNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}